# 动态规划

什么是动态规划（dynamic programming）？

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。核心就是将子问题的答案保存起来，以减少重复计算。

核心思想

leetcode原题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。

- 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去。
- 同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
- 要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去。
- 以此第推，到最后两级台阶，要跳到第二级台阶有两种方法，1+1和2。跳到第一级台阶只有一种方法。

将上面的思想总结出来就是：

```
f(10) = f(9) + f(8)
f(9) = f(8) + f(7)
f(8) = f(7) + f(6)
...
f(3) = f(2) + f(1)
```

最后可以归纳的公式就是 f(n) = f(n-1) + f(n-2)

当进行递归调用的时候，就会产生一个递归树，这其中包含大量的重复计算。从上面的公式就可以看到，f(8)被计算了两次。而解决办法就是将计算过的值存储下来，可以使用哈希表。

使用动态规划解决

动态规划的思想也是减少重复计算。使用动态规划和使用哈希表的区别是，哈希表是从上向下运算的f(10)->f(1)。 而动态规划是从下向上运算的f(1)->f(10)。动态规划是从小的问题开始逐步解决大的问题。

动态规划的特征是：最优子结构、状态转移方程、边界、重叠子问题。在青蛙条台阶的问题中。

- f(n-1)和f(n-2)称为f(n)的最优子结构。
- f(n) = f(n-1) + f(n-2) 就称为状态转移方程
- f(1) = 1，f(2) = 2 是边界条件
- f(10) = f(9) + f(8), f(9) = f(8) + f(7)。 f(8) 是重叠子问题。

------------------------------------------自底向上--------------------------------------------------------->

| 台阶数 | 1    | 2    | 3           | 4           | 5           | 6           | ...  | 10          |
| ------ | ---- | ---- | ----------- | ----------- | ----------- | ----------- | ---- | ----------- |
| 子结构 | f(1) | f(2) | f(3)        | f()         | f()         | f()         | ...  | f(10)       |
| 跳法   | 1    | 2    | f(1) + f(2) | f(2) + f(3) | f(3) + f(4) | f(4) + f(5) |      | f(8) + f(9) |
|        |      |      |             |             |             |             |      |             |

从上面表中可以看出，直接从最简单的步骤开始，就可以慢慢推导出后面的结论。



动态规划的套路

什么样的问题可以使用动态规划？

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑动态规划。

同样，基于青蛙跳台阶的问题：列出解决的思路

- 穷举分析
- 确定边界
- 找出规律，确定最优解
- 写出状态转移方程

1.穷举分析

如上表所示。

2.确定边界

当到一二级台阶的时候，f(1)=1  f(2)=2，这是可以直接确定的结果，所以这也是这个问题的边界。

3.找规律，确定最优子结构

当n>=3时，可以观察到，f(n) = f(n-1) + f(n-2)。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质。

4.写出状态转移方程

状态转移方程就是f(n) = f(n-1) + f(n-2)。
