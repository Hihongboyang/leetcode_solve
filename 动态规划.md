# 动态规划

什么是动态规划（dynamic programming）？

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。核心就是将子问题的答案保存起来，以减少重复计算。

核心思想

leetcode原题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。

- 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去。
- 同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
- 要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去。
- 以此第推，到最后两级台阶，要跳到第二级台阶有两种方法，1+1和2。跳到第一级台阶只有一种方法。

将上面的思想总结出来就是：

```
f(10) = f(9) + f(8)
f(9) = f(8) + f(7)
f(8) = f(7) + f(6)
...
f(3) = f(2) + f(1)
```

最后可以归纳的公式就是 f(n) = f(n-1) + f(n-2)

当进行递归调用的时候，就会产生一个递归树，这其中包含大量的重复计算。从上面的公式就可以看到，f(8)被计算了两次。而解决办法就是将计算过的值存储下来，可以使用哈希表。

使用动态规划解决

动态规划的思想也是减少重复计算。使用动态规划和使用哈希表的区别是，哈希表是从上向下运算的f(10)->f(1)。 而动态规划是从下向上运算的f(1)->f(10)。动态规划是从小的问题开始逐步解决大的问题。

动态规划的特征是：最优子结构、状态转移方程、边界、重叠子问题。在青蛙条台阶的问题中。

- f(n-1)和f(n-2)称为f(n)的最优子结构。
- f(n) = f(n-1) + f(n-2) 就称为状态转移方程
- f(1) = 1，f(2) = 2 是边界条件
- f(10) = f(9) + f(8), f(9) = f(8) + f(7)。 f(8) 是重叠子问题。

------------------------------------------自底向上--------------------------------------------------------->

| 台阶数 | 1    | 2    | 3           | 4           | 5           | 6           | ...  | 10          |
| ------ | ---- | ---- | ----------- | ----------- | ----------- | ----------- | ---- | ----------- |
| 子结构 | f(1) | f(2) | f(3)        | f()         | f()         | f()         | ...  | f(10)       |
| 跳法   | 1    | 2    | f(1) + f(2) | f(2) + f(3) | f(3) + f(4) | f(4) + f(5) |      | f(8) + f(9) |
|        |      |      |             |             |             |             |      |             |

从上面表中可以看出，直接从最简单的步骤开始，就可以慢慢推导出后面的结论。



动态规划的套路

什么样的问题可以使用动态规划？

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑动态规划。

同样，基于青蛙跳台阶的问题：列出解决的思路

- 穷举分析
- 确定边界
- 找出规律，确定最优解
- 写出状态转移方程

1.穷举分析

如上表所示。

2.确定边界

当到一二级台阶的时候，f(1)=1  f(2)=2，这是可以直接确定的结果，所以这也是这个问题的边界。

3.找规律，确定最优子结构

当n>=3时，可以观察到，f(n) = f(n-1) + f(n-2)。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质。

4.写出状态转移方程

状态转移方程就是f(n) = f(n-1) + f(n-2)。

------

## 不同路径问题

leetcode 第62题

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
```

这是一个路径规划问题，要寻找不同的路径，要从这个问题找到一些基本的概念和问题。

```
定义 f[i][j] 为到达位置(i,j)时的不同路径数量。
那么 f[n-1][m-1] 就是我们最终的答案，而f[i][j]=1 就是起始位置。
题目规定只能往下或者往右移动，因此按照 【当前可选方向】 进行分析。
1. 当前位置只能 【往下】移动，既有f[i][j] = f[i-1][j]  #当前在[i-1][j]
2. 当前位置只能 【往右】移动，既有f[i][j] = f[i][j-1]  #当前在[i][j-1]
3. 当前位置只能 【往下】也能【往右】移动，有f[i][j] = f[i][j-1] + f[i-1][j]
```

```c
int uniquePaths(int m, int n)
{
    int f[m][n];
    f[0][0] = 1;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i > 0 && j > 0)
            {
                f[i][j] = f[i - 1][j] + f[i][j - 1]; // [i][j]可以从上方和左方获取到值
            }
            else if (i > 0)
            {
                f[i][j] = f[i - 1][j]; // 只能从上方获取到值
            }
            else if (j > 0)
            {
                f[i][j] = f[i][j - 1]; // 只能从左方获取到值
            }
        }
    }
    return f[m - 1][n - 1];
}
```

接下来有些问题需要探讨：

1. 我们是如何确定可以使用动态规划来解决的?

   通常从 有无后效性 来进行分析。对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话， 那么这就是一个无后效 性的问题，可以考虑使用DP来解决。

2. 如何确定状态的定义？

   大多数情况是看经验，靠猜。也不是胡乱猜，有些题目的状态定义与【结尾】和【答案】有所关联。(比如说上题，推导出每个“终点”都会从他上方或者左方来获取他需要的值，他们有多少种走的方案)

3. 如何确定状态转移方程？

   如果定义对了，状态转移方程是对最后一步的分情况讨论。使用状态转移方程反过来验证我们状态定义的对不对：根据状态的定义，如果发现无法列出涵盖所有情况的状态转移方程，多半就是状态定义错了，需要重新定义了。

4. 状态转移的要求是什么？

   状态转移要做到，【不漏】还是【不重不漏】这主要取决于问题本身：

   只要求最值的话，只要不漏就行，重复值不影响。

   只要求方案数量，需要保证【不重不漏】。

5. 如何分析动态规划的时间复杂度？

   对于动态规划的复杂度/计算量分析，有多少状态，复杂度/计算量就是多少。

   因此一维复杂度是O(n)，二维的复杂度通常是平方的O(n2)。

   



















