# 动态规划

什么是动态规划（dynamic programming）？

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。核心就是将子问题的答案保存起来，以减少重复计算。

核心思想

leetcode原题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。

- 要想跳到第10级台阶，要么是先跳到第9级，然后再跳1级台阶上去;要么是先跳到第8级，然后一次迈2级台阶上去。
- 同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
- 要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去。
- 以此第推，到最后两级台阶，要跳到第二级台阶有两种方法，1+1和2。跳到第一级台阶只有一种方法。

将上面的思想总结出来就是：

```
f(10) = f(9) + f(8)
f(9) = f(8) + f(7)
f(8) = f(7) + f(6)
...
f(3) = f(2) + f(1)
```

最后可以归纳的公式就是 f(n) = f(n-1) + f(n-2)

当进行递归调用的时候，就会产生一个递归树，这其中包含大量的重复计算。从上面的公式就可以看到，f(8)被计算了两次。而解决办法就是将计算过的值存储下来，可以使用哈希表。

使用动态规划解决

动态规划的思想也是减少重复计算。使用动态规划和使用哈希表的区别是，哈希表是从上向下运算的f(10)->f(1)。 而动态规划是从下向上运算的f(1)->f(10)。动态规划是从小的问题开始逐步解决大的问题。

动态规划的特征是：最优子结构、状态转移方程、边界、重叠子问题。在青蛙条台阶的问题中。

- f(n-1)和f(n-2)称为f(n)的最优子结构。
- f(n) = f(n-1) + f(n-2) 就称为状态转移方程
- f(1) = 1，f(2) = 2 是边界条件
- f(10) = f(9) + f(8), f(9) = f(8) + f(7)。 f(8) 是重叠子问题。

------------------------------------------自底向上--------------------------------------------------------->

| 台阶数 | 1    | 2    | 3           | 4           | 5           | 6           | ...  | 10          |
| ------ | ---- | ---- | ----------- | ----------- | ----------- | ----------- | ---- | ----------- |
| 子结构 | f(1) | f(2) | f(3)        | f()         | f()         | f()         | ...  | f(10)       |
| 跳法   | 1    | 2    | f(1) + f(2) | f(2) + f(3) | f(3) + f(4) | f(4) + f(5) |      | f(8) + f(9) |
|        |      |      |             |             |             |             |      |             |

从上面表中可以看出，直接从最简单的步骤开始，就可以慢慢推导出后面的结论。



动态规划的套路

什么样的问题可以使用动态规划？

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑动态规划。

同样，基于青蛙跳台阶的问题：列出解决的思路

- 穷举分析
- 确定边界
- 找出规律，确定最优解
- 写出状态转移方程

1.穷举分析

如上表所示。

2.确定边界

当到一二级台阶的时候，f(1)=1  f(2)=2，这是可以直接确定的结果，所以这也是这个问题的边界。

3.找规律，确定最优子结构

当n>=3时，可以观察到，f(n) = f(n-1) + f(n-2)。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质。

4.写出状态转移方程

状态转移方程就是f(n) = f(n-1) + f(n-2)。

------

## 不同路径问题

leetcode 第62题

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
```

这是一个路径规划问题，要寻找不同的路径，要从这个问题找到一些基本的概念和问题。

```
定义 f[i][j] 为到达位置(i,j)时的不同路径数量。
那么 f[n-1][m-1] 就是我们最终的答案，而f[i][j]=1 就是起始位置。
题目规定只能往下或者往右移动，因此按照 【当前可选方向】 进行分析。
1. 当前位置只能 【往下】移动，既有f[i][j] = f[i-1][j]  #当前在[i-1][j]
2. 当前位置只能 【往右】移动，既有f[i][j] = f[i][j-1]  #当前在[i][j-1]
3. 当前位置只能 【往下】也能【往右】移动，有f[i][j] = f[i][j-1] + f[i-1][j]
```

```c
int uniquePaths(int m, int n)
{
    int f[m][n];
    f[0][0] = 1;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i > 0 && j > 0)
            {
                f[i][j] = f[i - 1][j] + f[i][j - 1]; // [i][j]可以从上方和左方获取到值
            }
            else if (i > 0)
            {
                f[i][j] = f[i - 1][j]; // 只能从上方获取到值
            }
            else if (j > 0)
            {
                f[i][j] = f[i][j - 1]; // 只能从左方获取到值
            }
        }
    }
    return f[m - 1][n - 1];
}
```

接下来有些问题需要探讨：

1. 我们是如何确定可以使用动态规划来解决的?

   通常从 【有无后效性 】来进行分析。对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话， 那么这就是一个【无后效性】的问题，可以考虑使用DP来解决。

2. 如何确定状态的定义？

   大多数情况是看经验，靠猜。也不是胡乱猜，有些题目的状态定义与【结尾】和【答案】有所关联。(比如说上题，推导出每个“终点”都会从他上方或者左方来获取他需要的值，他们有多少种走的方案)

3. 如何确定状态转移方程？

   如果定义对了，状态转移方程是对最后一步的分情况讨论。使用状态转移方程反过来验证我们状态定义的对不对：根据状态的定义，如果发现无法列出涵盖所有情况的状态转移方程，多半就是状态定义错了，需要重新定义了。

4. 状态转移的要求是什么？

   状态转移要做到，【不漏】还是【不重不漏】这主要取决于问题本身：

   只要求最值的话，只要不漏就行，重复值不影响。

   只要求方案数量，需要保证【不重不漏】。

   

5. 如何分析动态规划的时间复杂度？

   对于动态规划的复杂度/计算量分析，有多少状态，复杂度/计算量就是多少。

   因此一维复杂度是O(n)，二维的复杂度通常是平方的O(n2)。

------

leetcode 63题

与62题相似。只是现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

这与62题并没有任何不同。只是在碰到障碍的时候要将障碍位置的值设置为0

```C
int uniquePathsWithObstacles(int **obstacleGrid, int obstacleGridSize, int *obstacleGridColSize)
{
    
    int m = obstacleGridSize, n = obstacleGridColSize[0];
    int f[m][n];
    f[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (obstacleGrid[i][j] != 1)
            {
                if (i > 0 && j > 0)
                {
                    f[i][j] = f[i - 1][j] + f[i][j - 1];
                }
                else if (i > 0)
                {
                    f[i][j] = f[i - 1][j];
                }
                else if (j > 0)
                {
                    f[i][j] = f[i][j - 1];
                }
            }
            else
            {
                // 在障碍的位置设置为0，这样在计算后面的值时，就没有问题了。
                f[i][j] = 0;
            }
        }
    }
    return f[m - 1][n - 1];
}
```

------

leetcode 第64题

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

此题和上面那些题思路一样，只是加入了一个要寻找权值最小的路径的条件。针对这个条件我们只需要针对之前的方法稍加修改即可。

```
定义 f[i][j] 为到达位置(i,j)时的权值最小的路径的权值。
那么 f[n-1][m-1] 就是我们最终的答案，而f[0][0] = 起始位置权值 就是起始位置。
题目规定只能往下或者往右移动，因此按照 【当前可选方向】 进行分析。
1. 当前位置只能 【往下】移动，既有f[i][j] = f[i-1][j] + grid[i][j]  
2. 当前位置只能 【往右】移动，既有f[i][j] = f[i][j-1] + grid[i][j]
 	对于在边缘移动的路径不需要比较。
3. 当前位置能 【往下】也能【往右】移动，有f[i][j] = min(f[i][j-1] + f[i-1][j]) + grid[i][j]
```

```C
if (i > 0 && j > 0)
{
    f[i][j] = fmin(f[i - 1][j], f[i][j - 1]) + grid[i][j];
}
else if (i > 0)
{
    f[i][j] = f[i - 1][j] + grid[i][j];
}
else if (j > 0)
{
    f[i][j] = f[i][j - 1] + grid[i][j];
}
```

进阶问题： 如果想要输出最短的权值路径，该怎么办？

一个做法是使用另外一个结构，来记录路径。等遍历完成后再输出最段的权值路径。

```C
#include <stdio.h>
#include <limits.h>
#include <math.h>

int m, n;

int getIdx(int x, int y)
{
    return x * n + y;
}

int minPathSum(int **grid, int obstacleGridSize, int *obstacleGridColSize)
{
    // 题如64 题，此时如果要求在计算最小权值路径的基础上，输出权值最小的路径，怎么办？
    m = obstacleGridSize, n = obstacleGridColSize[0];
    int f[m][n];
    int g[m * n];
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == 0 && j == 0)
            {
                f[i][j] = grid[i][j];
            }
            else
            {
                int top = i - 1 >= 0 ? f[i - 1][j] : INT_MAX;
                int left = j - 1 >= 0 ? f[i][j - 1] : INT_MAX;
                f[i][j] = fmin(top, left) + grid[i][j];
                // 使用公式 x*n+y 对路径进行编码。将路径存储起来
                g[getIdx(i, j)] = top < left ? getIdx(i - 1, j) : getIdx(i, j - 1); 
            }
        }
    }
    int idx = getIdx(m - 1, n - 1);

    int path[m + n][2];
    path[m + n - 1][0] = m - 1;
    path[m + n - 1][1] = n - 1;

    for (int i = 1; i < m + n; i++)
    {
        // 方向对g中存储的路径进行解码
        path[m + n - 1 - i][0] = idx / n;
        path[m + n - 1 - i][1] = idx % n;
        idx = g[idx];
    }

    for (int i = 0; i < m + n -1; i++)
    {
        // 输出路径
        int x = path[i][0], y = path[i][1];
        printf("(%d, %d) ", x,y);
    }
    printf("\n");

    return f[m - 1][n - 1];
}
```

------

leetcode 第120题

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。

**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。

也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。



此题是如何判断出是使用动态规划求解的呢？ 使用的是有无后效性来判断的。

针对最后一行某个位置的值，依据题意只能从上一行的某个位置或者某两个位置其中之一转移而来，同时我们只关心这个值的大小，而并不关心他由什么路径得来。

**这显然就满足了「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。**

接下来是定义 状态。应该转移什么值来完成计算。

此处定义的是`f[i][j]`代表到达某个点的最小路径和。

```
定义 f[i][j] 代表到达某个点的最小路径和。
那么 f[n-1][m-1] 就是我们最终的答案，而f[0][0] = 起始位置权值 就是起始位置。
按照提示的规律有
1. 当j不等于0时，总是有左上节点的值可以继承
2. 当j不等于最后一个元素时，总有上方节点的值可以继承
```



```C
int minimumTotal(int **triangle, int triangleSize, int *triangleColSize)
{
    int m = triangleSize, n = triangleColSize[triangleSize-1], ans = INT_MAX;
    int f[m][n];
    f[0][0] = triangle[0][0];

    for (int i = 1; i < m; i++)
    {
        for (int j = 0; j < i + 1; j++)
        {
            f[i][j] = INT_MAX;
            if (j != 0)
            {
                f[i][j] = fmin(f[i][j], f[i - 1][j - 1]);
            }
            if (j != i)
            {
                f[i][j] = fmin(f[i][j], f[i - 1][j]);
            }
            f[i][j] += triangle[i][j];
        }
    }
    for (int i=0; i<n; i++)
    {
        ans = fmin(ans, f[m-1][i]);
    }

    return ans;
}
```

这里的存储空间还可以进行优化，因为和值只和前一层的数据有关，我们只要存储两层的数据即可。

f可以改成 `f[2][n]`。 存储的时候可以使用`f[i%2][j]`

------

leetcode 931题

给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 

在此题中，开始的节点是随机的，也就是可以从任何一个节点开始，这其实和从一个固定节点开始没有什么不同，如120那样，只是这里需要穷举全部可能。那么在什么时候，和在什么位置进行遍历是合适的呢？在第一行相当于已经拥有了所有的第一步可能性，而第二行则要第一行的所有可能性。第三行同样，以此类推。最后一行就包含了所有的可能性。

```c
int minFallingPathSum(int **matrix, int matrixSize, int *matrixColSize)
{
    int m = matrixSize, n = matrixColSize[0];
    int f[m][n], ans = INT_MAX;

    for (int i = 0; i < n; i++)
    {
        f[0][i] = matrix[0][i];
    }

    for (int i = 1; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (j == 0)
            {
                f[i][j] = fmin(f[i-1][j], f[i-1][j+1]);
            }
            else if (j == n-1)
            {
                f[i][j] = fmin(f[i-1][j-1], f[i-1][j]);
            }
            else
            {
                f[i][j] = fmin(fmin(f[i-1][j-1], f[i-1][j]), f[i-1][j+1]);
            }
            f[i][j] += matrix[i][j];
        }
    }

    for (int i=0; i<n; i++)
    {
        ans = fmin(ans, f[m-1][i]);
    }
    return ans;
}
```







